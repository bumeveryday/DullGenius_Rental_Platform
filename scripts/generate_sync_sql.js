const fs = require('fs');
const path = require('path');

// No need for Supabase client, just file I/O

// 1. CSV Parser
function parseCSV(text) {
    const lines = text.trim().split('\n');
    const parseLine = (line) => {
        const row = [];
        let current = '';
        let insideQuote = false;

        for (let i = 0; i < line.length; i++) {
            const char = line[i];
            if (char === '"') {
                insideQuote = !insideQuote;
            } else if (char === ',' && !insideQuote) {
                row.push(current.trim().replace(/^"|"$/g, ''));
                current = '';
            } else {
                current += char;
            }
        }
        row.push(current.trim().replace(/^"|"$/g, ''));
        return row;
    };

    return lines.slice(1).map(parseLine); // Skip header
}

async function generateSQL() {
    console.log("ðŸš€ Generating SQL...");

    try {
        // Read CSV
        const csvPath = path.resolve(__dirname, '../archive/DullG_BoardGame_Rental - Games (2).csv');
        if (!fs.existsSync(csvPath)) {
            throw new Error(`CSV not found at: ${csvPath}`);
        }
        const csvContent = fs.readFileSync(csvPath, 'utf8');
        const rows = parseCSV(csvContent);
        console.log(`âœ… Loaded ${rows.length} rows from CSV.`);

        // Count Quantities (Name based)
        const countsByName = {};
        rows.forEach(row => {
            const name = row[1]; // Index 1 is 'name'
            if (name) {
                const normalized = name.trim();
                countsByName[normalized] = (countsByName[normalized] || 0) + 1;
            }
        });

        // Generate SQL
        let sqlStatements = [];
        sqlStatements.push(`-- Generated by scripts/generate_sync_sql.js at ${new Date().toISOString()}`);
        sqlStatements.push("BEGIN;");

        // 1. Reset all quantities first? Or just update known ones?
        // If we only update known ones, unknown games remain as they are.
        // Given 'All games are 3', implies previous migration set 3.
        // We should explicitly set quantity to CSV count.

        for (const [name, count] of Object.entries(countsByName)) {
            const safeName = name.replace(/'/g, "''");
            // Update quantity
            // Note: using name as key is slightly risky if duplicates exist in DB, but we assume unique names or update all matching
            sqlStatements.push(`UPDATE public.games SET quantity = ${count} WHERE name = '${safeName}';`);
        }

        // 2. Recalculate available_count for ALL games
        // Available = Quantity - (Active Rentals + Active Dibs)
        // Active Rental: returned_at IS NULL
        // Active Dibs: type = 'DIBS' (and returned_at IS NULL)

        sqlStatements.push("");
        sqlStatements.push("-- Recalculate available_count");
        sqlStatements.push(`
UPDATE public.games g
SET available_count = quantity - (
    SELECT COUNT(*) 
    FROM public.rentals r 
    WHERE r.game_id = g.id 
      AND r.returned_at IS NULL
);
`);

        // 3. Ensure non-negative
        sqlStatements.push("UPDATE public.games SET available_count = 0 WHERE available_count < 0;");

        sqlStatements.push("COMMIT;");

        const sqlContent = sqlStatements.join('\n');
        const outputPath = path.resolve(__dirname, '../database/update_quantities_v2.sql');
        fs.writeFileSync(outputPath, sqlContent, 'utf8');

        console.log(`ðŸŽ‰ SQL Generated at: ${outputPath}`);
        console.log(`ðŸ“ Update Statements: ${Object.keys(countsByName).length}`);

    } catch (e) {
        console.error("ðŸ”¥ Failed:", e);
    }
}

generateSQL();
